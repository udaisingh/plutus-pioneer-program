{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}

module Main where

import           Plutus.Model         (Run, TypedValidator (TypedValidator),
                                       adaValue, defaultBabbage, mustFail, testNoErrors,
                                       toV2, FakeCoin (FakeCoin), fakeValue, UserSpend, Tx,
                                       DatumMode (HashDatum), userSpend, payToScript, spendScript,
                                       payToKey, newUser, spend, submitTx, utxoAt, valueAt, logError)
import           PlutusTx.Prelude     (($), Integer, Eq ((==)), (&&))
import           Prelude              (IO, (.), (<>), Monoid (mconcat), Traversable (mapM), Num ((-)))
import qualified ExploitableSwap      as OnChain
import qualified PatchedSwap          as PatchedOnChain (validator)
import           Test.Tasty           (defaultMain, testGroup)
import           Plutus.V2.Ledger.Api (PubKeyHash, Value, TxOutRef, TxOut (txOutValue))
import           Control.Monad (unless)

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending using vulnerable script succeeds" $ normalSpending swapScript
      , good "Double spending using vulnerable script succeeds" $ doubleSpending swapScript
      , good "Normal spending using patched script succeeds   " $ normalSpending patchedSwapScript
      , bad  "Double spending using patched script fails      " $ doubleSpending patchedSwapScript
      ]
 where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"
 
type HomeworkScript = TypedValidator OnChain.DatumSwap ()

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

patchedSwapScript :: HomeworkScript
patchedSwapScript = TypedValidator $ toV2 PatchedOnChain.validator

lockingTx :: HomeworkScript -> PubKeyHash -> Integer -> UserSpend -> Value -> Tx
lockingTx script benef price usp val =
  mconcat
    [ userSpend usp
    , payToScript script (HashDatum (OnChain.DatumSwap benef price)) val
    ]


consumingTx :: HomeworkScript -> PubKeyHash -> Integer -> PubKeyHash -> UserSpend -> TxOutRef -> Value -> Tx
consumingTx script benef price buyer sp2 ref token =
  mconcat
    [ spendScript script ref () (OnChain.DatumSwap benef price)
    , payToKey buyer token
    , payToKey benef $ adaValue price
    , userSpend sp2
    ]


doubleConsumingTx :: HomeworkScript -> PubKeyHash -> Integer -> PubKeyHash -> UserSpend -> TxOutRef -> TxOutRef -> Value -> Tx
doubleConsumingTx script benef price buyer sp2 ref1 ref2 token =
  mconcat
    [ spendScript script ref1 () (OnChain.DatumSwap benef price)
    , spendScript script ref2 () (OnChain.DatumSwap benef price)
    , payToKey buyer $ token <> token -- Two tokens to buyer
    , payToKey benef $ adaValue price -- Payment for only one token to beneficiary
    , userSpend sp2
    ]

---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------

normalSpending :: HomeworkScript -> Run ()
normalSpending script = do
 -- SETUP USERS (one with a super cool token)
  u1 <- newUser (adaValue 1000 <> fakeValue scToken 1)
  u2 <- newUser (adaValue 1000)
  -- USER 1 LOCKS TOKEN IN VALIDATOR
  let token = adaValue 1 <> fakeValue scToken 1
      price = 350
  sp1 <- spend u1 token                       
  submitTx u1 $ lockingTx script u1 price sp1 token
  -- USER 2 BUYS TOKEN
  utxos <- utxoAt script
  -- logError $ show utxos
  let [(ref, out)] = utxos                 
  sp2 <- spend u2 (adaValue price)                       
  submitTx u2 $ consumingTx script u1 price u2 sp2 ref (txOutValue out) 
  -- -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]         
  let expectedV1 = adaValue 999 <> adaValue price
  let expectedV2 = adaValue (1000 - price) <> token
  unless (v1 == expectedV1 && v2 == expectedV2) $ 
    logError "Final balances are incorrect"


doubleSpending :: HomeworkScript -> Run ()
doubleSpending script = do
  -- SETUP USERS (one with a super cool token)
  u1 <- newUser (adaValue 1000 <> fakeValue scToken 2)
  u2 <- newUser (adaValue 1000)
  -- USER 1 LOCKS TOKEN IN VALIDATOR TWICE
  let token = adaValue 1 <> fakeValue scToken 1
      price = 350
  sp1 <- spend u1 token                       
  submitTx u1 $ lockingTx script u1 price sp1 token
  sp1' <- spend u1 token                       
  submitTx u1 $ lockingTx script u1 price sp1' token
  -- USER 2 BUYS ONE TOKEN AND STEALS THE OTHER
  utxos <- utxoAt script
  let [(ref1, out),(ref2, _)] = utxos                 
  sp2 <- spend u2 (adaValue price)                       
  submitTx u2 $ doubleConsumingTx script u1 price u2 sp2 ref1 ref2 (txOutValue out) 
  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]         
  let expectedV1 = adaValue 998 <> adaValue price
  let expectedV2 = adaValue (1000 - price) <> token <> token
  unless (v1 == expectedV1 && v2 == expectedV2) $ 
    logError "Final balances are incorrect"
