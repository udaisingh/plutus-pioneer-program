{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE NoImplicitPrelude #-}

module Main where

import qualified ExploitableSwap as OnChain
import Plutus.Model
  ( FakeCoin (FakeCoin),
    Run,
    TypedValidator (TypedValidator),
    adaValue,
    defaultBabbage,
    fakeValue,
    mustFail,
    testNoErrors,
    toV2,
  )
import Plutus.V1.Ledger.Value (Value)
import PlutusTx.Prelude (($))
import Test.Tasty (TestTree, defaultMain, testGroup)
import Test.Tasty.HUnit (assertEqual, testCase)
import Prelude (IO, undefined, (.), (<>))

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending" normalSpending,
        bad "Double spending" doubleSpending
      ]
  where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"

type HomeworkScript = TypedValidator OnChain.DatumSwap ()

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

lockingTx :: undefined
lockingTx = undefined

consumingTx :: undefined
consumingTx = undefined

doubleConsumingTx :: undefined
doubleConsumingTx = undefined

---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------

normalSpending :: Run ()
normalSpending = do
  let inputToken = FakeCoin "Token A"
      outputToken = FakeCoin "Token B"
      expected :: Value
      expected = adaValue 10_000_000 <> fakeValue outputToken 100
  assertEqual "Normal spending test" expected (calculateValue inputToken outputToken)

doubleSpending :: Run ()
doubleSpending = do
  let inputToken = FakeCoin "Token C"
      outputToken = FakeCoin "Token D"
      expected :: Value
      expected = adaValue 5_000_000 <> fakeValue outputToken 50
  testNoErrors expected defaultBabbage (OnChain.DatumSwap inputToken outputToken) swapScript
